{"mappings":"AAAA;IACE,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC;CAChC;AAED,qBAAM,cAAc;IAalB,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC;IAEnB,MAAM,CAAC,aAAa,EAAE,KAAK,CAAC;gBAEhB,EAAE,OAAoB,EAAE,GAAE,qBAA0B;IAYhE,MAAM,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,EAAE,aAAa,EAAE,KAAK;IA4B9C,IAAI,aAET;IAEK,OAAO,aAUZ;CAqGH;AAED,eAAe,cAAc,CAAC","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"interface MarqueeContentOptions {\n  element?: string | HTMLElement;\n}\n\nclass MarqueeContent {\n  private readonly gsap: never;\n\n  private readonly MM: never;\n\n  private timeline: never;\n\n  private readonly element: HTMLElement | null;\n\n  private resizeObserver: ResizeObserver;\n\n  private animationFrame: number | null = null;\n\n  static gsap: never;\n\n  static ScrollTrigger: never;\n\n  constructor({ element = '.marquee' }: MarqueeContentOptions = {}) {\n    this.gsap = MarqueeContent.gsap ?? (window as never).gsap;\n    this.MM = this.gsap.matchMedia();\n    this.timeline = null;\n    this.element = typeof element === 'string' ? document.querySelector(element) : element;\n\n    if (!this.element) return;\n\n    this.resizeObserver = new ResizeObserver(MarqueeContent.debounce(this.update));\n    this.resizeObserver.observe(this.element);\n  }\n\n  static registerGSAP(gsap: never, ScrollTrigger: never) {\n    MarqueeContent.gsap = gsap;\n    MarqueeContent.ScrollTrigger = ScrollTrigger;\n  }\n\n  private commonInit = () => {\n    if (this.element) {\n      this.clearTimeline();\n      this.cloneElements();\n      this.setBreakpoints();\n      this.applySkew();\n\n      this.timeline = this.createAnimation();\n    }\n  };\n\n  private update = () => {\n    if (this.animationFrame !== null) {\n      cancelAnimationFrame(this.animationFrame);\n    }\n\n    this.animationFrame = requestAnimationFrame(() => {\n      this.commonInit();\n\n      MarqueeContent.ScrollTrigger.refresh();\n    });\n  };\n\n  public init = () => {\n    this.commonInit();\n  };\n\n  public destroy = () => {\n    if (this.animationFrame !== null) {\n      cancelAnimationFrame(this.animationFrame);\n    }\n\n    if (this.element) {\n      this.clearTimeline();\n    }\n\n    this.resizeObserver?.disconnect();\n  };\n\n  private static debounce(func: (...args: never[]) => void) {\n    let timer: number | null = null;\n\n    return (...args: never[]) => {\n      if (timer !== null) {\n        cancelAnimationFrame(timer);\n      }\n\n      timer = requestAnimationFrame(() => func(...args));\n    };\n  }\n\n  private createAnimation() {\n    this.timeline?.kill();\n\n    const timeline = this.gsap.timeline({\n      scrollTrigger: {\n        trigger: this.element,\n        start: 'top bottom',\n        end: 'bottom top',\n        toggleActions: 'resume pause resume pause',\n        onUpdate: (self: never) => {\n          if (this.element?.dataset.mcDirection === 'ltr') {\n            timeline.timeScale(-1);\n          } else if (this.element?.dataset.mcDirection === 'auto') {\n            timeline.timeScale(self.direction);\n          }\n        },\n      },\n    });\n\n    this.MM.add(this.element?.dataset.mcBreakpoint, () => {\n      const mcSpeed = parseFloat(this.element?.dataset.mcSpeed || '20');\n      const speed = mcSpeed;\n\n      timeline.to(this.element!.children, {\n        duration: speed,\n        x: '-100%',\n        repeat: -1,\n        ease: 'none',\n      });\n\n      timeline.totalProgress(0.5);\n\n      return () => timeline?.kill();\n    });\n\n    return timeline;\n  }\n\n  private setBreakpoints() {\n    if (this.element!.dataset.mcMax) {\n      this.element!.dataset.mcBreakpoint = `(max-width: ${parseFloat(this.element!.dataset.mcMax) - 0.02}px)`;\n    } else if (this.element!.dataset.mcMin) {\n      this.element!.dataset.mcBreakpoint = `(min-width: ${this.element!.dataset.mcMin}px)`;\n    } else {\n      this.element!.dataset.mcBreakpoint = '';\n    }\n  }\n\n  private clearTimeline() {\n    this.timeline?.kill();\n    this.timeline = null;\n    this.gsap.set(this.element!.children, { clearProps: 'all' });\n  }\n\n  private cloneElements() {\n    const removingClones = () => {\n      while (this.element!.childElementCount > 1) {\n        this.element!.removeChild(this.element!.lastChild as ChildNode);\n      }\n    };\n\n    removingClones();\n\n    this.MM.add(this.element!.dataset.mcBreakpoint, () => {\n      const requiredQuantity = Math.ceil(this.element!.scrollWidth / this.element!.firstElementChild!.clientWidth + 2);\n\n      if (this.element!.childElementCount < requiredQuantity) {\n        const fragment = document.createDocumentFragment();\n        const clones = Array.from({ length: requiredQuantity - 1 }, () => this.element!.firstElementChild!.cloneNode(true) as HTMLElement);\n\n        clones.forEach((clone) => fragment.appendChild(clone));\n\n        this.element!.appendChild(fragment);\n      }\n\n      return removingClones;\n    });\n  }\n\n  private applySkew() {\n    if (!this.element?.dataset.mcSkew) return;\n\n    const { style } = this.element;\n\n    style.transformOrigin = 'center center';\n    style.transform = `skew(0deg, ${this.element.dataset.mcSkew}deg)`;\n  }\n}\n\nexport default MarqueeContent;\n"],"names":[],"version":3,"file":"index.d.ts.map"}